# 함수 정의
**인사이드 자바스크립트**를 읽다가, 함수 정의 부분에서 함수 리터럴, 함수 표현식에 대한 내용 + 호이스트에 대한 내용을 읽게되었다.    
정확한 개념을 알지 못한 채 사용했던 표현식들을 정리해보고, 막연하게 알고 있던 호이스트에 대한 내용을 정리해보려고 한다.    
    
자바스크립트에서 함수를 생성하는 방법은 3가지가 있다.    

- 함수 선언문 (function statement)
- 함수 표현식 (function expression)
- Function() 생성자 함수
    
각각의 방식에 따라 함수 동작이 미묘하게 차이가 난다.    
    
세 방법의 차이를 알아보기 전에, 함수 리터럴 방식부터 알아보자.    
자바스크립트에서는 함수도 일반 객체처럼 값으로 취급된다. 그렇기 때문에, 객체 리터럴 방식으로 일반 객체를 생성하는 것 처럼 자바스크립트에서는 **함수 리터럴**을 이용해 함수를 생성할 수 있다.    
    
**함수 리터럴**
```js
function add(x, y) {
    return x + y;
}
```
- 함수명은 선택사항이다. 함수명이 없는 함수를 **익명 함수**라 한다.

## 함수 선언문
함수 리터럴 형식과 같다. 
```js
function add(x, y) {
    return x + y;
}
```
주의할 점은 **반드시 함수명이 정의되어 있어야 한다**. 

## 함수 표현식
위에서 함수도 하나의 값처럼 취급된다고 언급했다. 따라서 함수도 숫자나 문자열처럼 변수에 할당 가능하다. 함수표현식은    

1. 리터럴 방식으로 함수를 만들고
2. 이 함수를 변수에 할당하여 함수를 생성하는 방식

으로 설명할 수 있다.    
```js
const add = function (x, y) {
    return x + y;
}
```
여기서 함수 리터럴로 생성한 함수는 **함수명이 없으므로 익명 함수**이다. (함수 이름은 선택사항이며 보통 사용하지 않는다.)    
    
이 함수는 자바스크립트 엔진에 의해 다음과 같은 함수 표현식 형태로 변경된다.
```js
const add = function add(x, y) {
    return x + y;
}
```
주의할 점은 `add` 변수는 함수를 참조하는 변수이지, **함수 이름이 아니다.** 
    
또한 `const plus = add;`와 같이 함수의 참조값을 또 다른 변수에 할당할 수 있다.
    
> 즉, 리터럴로 생성된 익명 함수를 `add`, `plus` 함수 변수가 참조하고 있는 구조이다.

![익명 함수를 add, plus 변수가 참조하고 있는 구조](/images/functionStatementAndExpression01.png)

그런데, 리터럴로 함수를 생성할 때 함수 이름을 포함할 수도 있다. 이를 **기명 함수 표현식**이라고 한다. 기명 함수 표현식을 사용할때에는 주의할 점이 있다.
```js
const add = function sum(x, y) {
    return x + y;
}

console.log(add(3,4)); //7
console.log(sum(3,4)); //Uncaught ReferenceError: sum is not defined
```
함수 표현식에 사용된 함수 이름은 정의된 함수 내부에서 해당 함수를 재귀적으로 호출할 때 사용된다.    
    
리터럴로 익명 함수를 생성한 `add()` 예제를 다시 보면, 외부에서 add 함수 변수를 호출했을 때, add 함수 변수 내부의 -자바스크립트 엔진에 의해 변환된- add()함수를 호출한 것이다.    
    
이러한 특성을 이용하면 함수 코드 내부에서 함수 이름으로 재귀적인 호출 처리가 가능하다.    
    
```js
const factorialConst = function factorial(n) {
    if(n <= 1) {
        return 1;
    }
    return n * factorial(n-1);
};

console.log(factorialConst(3)); //6
console.log(factorial(3)); //undefined
```
> Tip : 함수 선언문 방식으로 함수를 정의할때는 함수 끝에 세미콜론(;)을 붙이지 않지만, 함수 표현식 방식으로 함수를 정의할때는 함수 끝에 세미콜론을 붙이는것이 관습이다.

## Function() 생성자

일반적으로 자주 사용 되지 않으므로, 이러한 작성 방법이 있다 정도로만 알고 자세하게 다루지는 않는다.

    const add = new Function('x', 'y', 'return x + y');
   

**함수 표현식을 사용해야한다고?**

자바스크립트 Guru로 알려진 더글라스 크락포드는 **함수 표현식**만을 사용할 것을 권하고 있다. **함수 호이스팅 때문이다.**

함수 호이스팅을 간단하게 설명하면, "끌어올린다"라는 뜻으로 변수와 함수를 소스의 맨 위로 이동시키는 자바스크립트의 특성이다. 

함수 선언문의 경우, 함수 생성보다 호출이 선행되어도 문제 없이 함수가 실행된다.
```js
console.log(add(2, 3)) //5

function add(x, y) {
    return x + y;
}

console.log(add(2, 3)) //5
```
이러한 함수 호이스팅은 함수를 사용하기 전에 반드시 선언해야 한다는 규칙을 무시하므로, 코드 구조를 망칠 수 있다고 지적한다.

함수 표현식의 경우, 호이스팅이 일어나지 않는다.
```js
console.log(add(2, 3)) //add is not a function

const add = function (x, y) {
    return x + y;
}

console.log(add(2, 3)) //5
```
    
호이스팅에 대해 더 공부한 내용은 [호이스팅](./javascript/hoisting.md)에 정리해 두었다.